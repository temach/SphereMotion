import mathfrom OpenGL.GL import *from OpenGL.GLU import *from agk.matrix44 import *from agk.vector3 import *from agk.quaternion import *class RootedRigidColorMesh( object ):    def __init__(self, matrix, display_list_id, colour):        self.id = id(self)        self.colour = colour        self.matrix = matrix.copy()        self.display_list_id = display_list_id        self.default_orient()    def default_orient(self):        try:            to_origin = -Vector3( self.matrix.translate ).get_normalised()        except ZeroDivisionError:       # this means that to_origin is a zero vector, so object is at the origin, so its orientation is not important, so skip it.            return        myup = Vector3( self.matrix.y_axis ).get_normalised()        dot = myup.dot( to_origin )        if abs(dot) < 1.0:            orient_quat = Quaternion.from_two_vec3( myup, to_origin, dotprod=dot, unit=True ).get_normalised()            self.matrix = self.matrix * orient_quat.to_matrix44()    def render(self):        glColor( self.colour )        glPushMatrix()        glMultMatrixf(self.matrix.to_opengl())        glCallList( self.display_list_id )        glPopMatrix()class MovingRigidColorMesh( RootedRigidColorMesh ):    def __init__(self, movement_speed, rotation_speed, *args ):        super(MovingRigidColorMesh, self).__init__( *args[-3:] )        self.location = Vector3( self.matrix.translate )        self.movement_speed = movement_speed        self.rotation_speed = rotation_speed        self.motion_dir = Vector3(0.0, 0.0, 0.0)        self.roto_dir = Vector3(0.0, 0.0, 0.0)        self.quat = Quaternion.from_matrix( self.matrix )        print "All is good"    def update(self, TimeDelay):        if self.motion_dir:         # change displacement            pos = self.location            direction = Vector3(self.matrix.z_axis[:3]) * self.motion_dir.z + Vector3(self.matrix.x_axis[:3]) * self.motion_dir.x            delta_pos = direction * self.movement_speed * TimeDelay            quat_pos = Quaternion.from_two_vec3( pos, pos + delta_pos ).get_normalised()            self.location = quat_pos.rotate_vec3( pos )            #self.quat = quat_pos * self.quat        # tilt the object, to help keep it parallel to sphere's surface        if self.roto_dir:       # rotate according to brain input            rotation = self.roto_dir * self.rotation_speed * TimeDelay            quat_roto = Quaternion.from_euler_angles( *rotation )            self.quat = self.quat * quat_roto        to_origin = -self.location.get_normalised()        myup = Vector3( self.matrix.y_axis[:3] )        dot = myup.dot( to_origin )        if abs(dot) < 1.0:                  # set the object's y_axis to point to the origin            stable_quat = Quaternion.from_two_vec3( myup, to_origin, dotprod=dot ).get_normalised()            self.quat = stable_quat * self.quat        self.matrix = self.quat.normalise().to_matrix44()        self.matrix.translate = self.location        return delta_pos