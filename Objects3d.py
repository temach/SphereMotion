import mathfrom OpenGL.GL import *from OpenGL.GLU import *from agk.matrix44 import *from agk.vector3 import *class RootedRigidColorMesh(object):    def __init__(self, matrix, display_list_id, colour):        self.id = id(self)        self.colour = colour        self.matrix = matrix.copy()        self.display_list_id = display_list_id    def render_in_series(self):        glColor( self.colour )        glPushMatrix()        glMultMatrixf(self.matrix.to_opengl())        glCallList( self.display_list_id )        glPopMatrix()class MovingRigidColorMesh( object ):    def __init__(self, matrix, display_list_id, color ):        self.id = id(self)        self.colour = colour        self.matrix = matrix.copy()        self.display_list_id = None        self.location = Vector3( self.matrix.translate[:3] )        self.movement_speed = kwargs.get( "MovementSpeed", 5.0 )        self.rotation_speed = kwargs.get( "RotationSpeed", math.radians(50.0) )        self.motion_dir = Vector3(0.0, 0.0, 0.0)        self.roto_dir = Vector3(0.0, 0.0, 0.0)    def move(self, TimeDelay):        # change the location        loc = self.location        direction = Vector3(self.matrix.z_axis[:3]) * self.motion_dir.z + Vector3(self.matrix.x_axis[:3]) * self.motion_dir.x        delta_pos = direction * self.movement_speed * TimeDelay        dq_pos = get_quat_to( loc, loc + delta_pos )        self.location = dq_pos.transform_vec( loc )        # tilt the object slightly, to help keep it parallel to sphere's surface        koeff = min( TimeDelay, 0.08 ) * 10        roto_q = nlerp( koeff, Quaternion(1.0), dq_pos, shortest=True)        dq_m = dq_pos.get_conjugated().get_inversed().to_matrix44()        self.matrix = dq_m * self.matrix    def rotate(self, TimeDelay):        # rotate according to user input (keyboard and/or mouse)        rotation = self.roto_dir * self.rotation_speed * TimeDelay        rotation_matrix = Matrix44.xyz_rotation( *rotation )        self.matrix = self.matrix * rotation_matrix        # ensure that x axis is parallel to the sphere's surface. (so you don't rotate along z axis)        # actually its more like: ensure that x axis is perpendicular to vector to the origin        myright = Vector3(self.matrix.x_axis[:3])        to_origin = -self.location.get_normalised()        dot = myright.dot( to_origin )        if  abs(dot) > 0.1:            other_dot = math.copysign( 1.0 - dot, dot )             # this is a hack.            full_quat = get_quat_to( to_origin, myright, dotprod=other_dot )            koeff = min( TimeDelay, 0.06 )            quat = nlerp( koeff, Quaternion(1.0), full_quat, shortest=True)            self.matrix = quat.to_matrix44() * self.matrix    def update(self, TimeDelay):        if self.motion_dir:         # change displacement and tilt object to help keep parallel to the sphere            self.move( TimeDelay )        if self.roto_dir:       # rotate according to input from brain            self.rotate( TimeDelay )    def render(self):        glPushMatrix()        glMultMatrixf(self.matrix.get_inverse().to_opengl())        glCallList(self.display_list_id)        glPopMatrix()    def create_display_list(self):        list_id = glGenLists(1)        glNewList(list_id, GL_COMPILE)        self.draw()        glEndList()        return list_id    def draw(self):        glBegin(GL_TRIANGLES)        glColor( self.color )        for index_ref in self.v_n_index:            glVertex3fv( self.vertices[index_ref[0]] )            glNormal3fv( self.normals[index_ref[1]] )        glEnd()