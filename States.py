import randomfrom agk.vector3 import *import pdbclass StateMachine(object):    def __init__(self):        self.states = {}        self.active_state = None    def add_state(self, state):        self.states[state.name] = state    def setup(self):        self.active_state = self.states["exploring"]    def think(self, *args):        responce = self.active_state.do_actions( *args )        new_state = self.active_state.check_exit_conditions()        if new_state:            self.set_state( new_state )        return responce    def set_state(self, new_state):        self.active_state.exit_actions()        self.active_state = self.states[new_state]        self.active_state.entry_actions()class StateBasic( object ):    def __init__(self, body):        self.body = body    def entry_actions(self):        pass    def do_actions(self):       # called per frame        pass    def check_exit_conditions(self):        pass    def exit_actions(self):        passclass StateExploring( StateBasic ):    def __init__(self, body):        self.name = "exploring"        super(StateExploring, self).__init__( body )        self.location = self.body.location.copy()        self.velocity = Vector3(self.body.matrix.z_axis)        self.acceleration = Vector3(0, 0, 0)        self.maxforce =  0.01   # Maximum steering force        self.maxspeed =  0.03  # Maximum speed    def get_random_dir(self):        angle = random(TWO_PI)        velocity = Vector3(math.cos(angle), math.sin(angle))    def apply_force(self, force):        # We could add mass here if we want A = F / M        self.acceleration += force    def flock(self, boids):        #sep = self.separate( boids )   # Separation        ali = self.align( boids )      # Alignment        #coh = self.cohesion( boids )   # Cohesion        # Arbitrarily weight these forces        #sep *= 1.5        ali *= 1.0        #coh *= 1.0        # Add the force vectors to acceleration        #self.apply_force( sep )        self.apply_force( ali )        #self.apply_force( coh )    # Separation    # Method checks for nearby boids and steers away    def separate( self, boids ):        desiredseparation = 4.0        steer = Vector3(0, 0, 0)        count = 0.0        # For every boid in the system, check if it's too close        for other in boids:            d = distance3d( self.location, other.location )            # If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)            if (d > 0) and (d < desiredseparation):                # Calculate vector pointing away from neighbor                diff = Vector3.from_points(other.location, self.location)                diff.normalize()                diff /= d           # Scalar division to weight by distance                steer += diff                count += 1            # Keep track of how many        # Average -- divide by how many        if (count > 0):            steer /= count        # As long as the vector is greater than 0        if (steer.length() > 0.001):            # Implement Reynolds: Steering = Desired - Velocity            steer.set_length( self.maxspeed )            steer -= self.velocity            steer.set_length( self.maxforce )        return steer    # Alignment    # For every nearby boid in the system, calculate the average velocity    def align( self, boids ):        neighbordist = 15        sum = Vector3(0, 0, 0)        count = 0.0        for other in boids:            d = distance3d( self.location, other.location )            if (d > 0) and (d < neighbordist):                sum += other.velocity                count += 1        if (count <= 0):            return Vector3(0, 0, 0)        if not sum:            steer = self.velocity.set_length( self.maxforce )      # maybe other way around            return -steer        sum /= count        # Implement Reynolds: Steering = Desired - Velocity        sum.set_length( self.maxspeed )        steer = Vector3.from_points( self.velocity, sum )      # maybe other way around        steer.set_length( self.maxforce )        return steer    # Cohesion    # For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location    def cohesion( self, boids ):        neighbordist = 15        sum = Vector3(0, 0, 0)   # Start with empty vector to accumulate all locations        count = 0.0        for other in boids:            d = distance3d( self.location, other.location )            print "Another distance ", d            if (d > 0) and (d < neighbordist):                sum += other.location # Add location                count += 1        if (count <= 0.0):            return Vector3(0, 0, 0)        sum /= count        return self.seek( sum )  # Steer towards the location    # A method that calculates and applies a steering force towards a target    # STEER = DESIRED MINUS VELOCITY    def seek( self, target ):        desired = Vector3.from_points( self.location, target )  # A vector pointing from the location to the target        # Scale to maximum speed        desired.set_length( self.maxspeed )        # Steering = Desired minus Velocity        steer = Vector3.from_points( self.velocity, desired )        steer.set_length( self.maxforce )      # Limit to maximum steering force        return steer    # Method to update location    def update(self):        # Update velocity        #self.velocity += self.acceleration        # Limit speed        #self.velocity.set_length( self.maxspeed )        #self.location += self.velocity        # Reset accelertion to 0 each cycle        self.acceleration.make_zero()    def do_actions(self, boids):        myboids = boids.copy()        del myboids[ self.body.id ]        self.acceleration.make_zero()        self.location = self.body.location.copy()        self.velocity = self.body.velocity.copy()        self.flock( myboids.values() )        #self.update()        print "Acceleration ", self.acceleration        print "Compared to velocity   ", self.velocity        print        return self.acceleration.copy()    def check_exit_conditions(self):        return False    def entry_actions(self):        pass    def exit_actions(self):        pass