import randomfrom agk.vector3 import *import pdb# Comparison threshold_epsilon = 1E-7class StateMachine(object):    def __init__(self):        self.states = {}        self.active_state = None    def add_state(self, state):        self.states[state.name] = state    def think(self, *args):        responce = self.active_state.do_actions( *args )        new_state = self.active_state.check_exit_conditions()        if new_state:            self.set_state( new_state )        return responce    def set_initial_state(self, initial_state_name):        self.active_state = self.states[initial_state_name]        self.active_state.entry_actions()    def set_state(self, new_state_name):        self.active_state.exit_actions()        self.active_state = self.states[new_state_name]        self.active_state.entry_actions()class StateBasic( object ):    def __init__(self, body):        self.body = body    def entry_actions(self):        pass    def do_actions(self):       # called per frame        pass    def check_exit_conditions(self):        pass    def exit_actions(self):        passclass StateFlockTravel( StateBasic ):    def __init__(self, body):        self.name = "exploring"        super(StateFlockTravel, self).__init__( body )        self.acceleration = Vector3(0, 0, 0)        self.maxforce =  self.body.acceleration_force       # Maximum steering force, determines the overall impact of acceleration        self.maxspeed =  self.body.movement_speed       # Maximum speed        # Distances at which the forces come into effect. Distances are squared to speed up comparisons.        self.separationdist = self.body.separationdist **2        self.alignmentdist = self.body.alignmentdist **2        self.cohesiondist = self.body.cohesiondist **2        # Arbitrary weight the forces that compose the acceleration.        self.separationforce = self.body.separationforce        self.alignmentforce = self.body.alignmentforce        self.cohesionforce = self.body.cohesionforce    def apply_force(self, force):        # We could add mass here if we want A = F / M        self.acceleration += force    def flock(self, boids):        sep = self.separate( boids )   # Separation        ali = self.align( boids )      # Alignment        coh = self.cohesion( boids )   # Cohesion        # Arbitrarily weight these forces        sep *= self.separationforce        ali *= self.body.alignmentforce        coh *= self.body.cohesionforce        # Add the force vectors to acceleration        self.apply_force( sep )        self.apply_force( ali )        self.apply_force( coh )    # Separation    # Method checks for nearby boids and steers away    def separate( self, boids ):        desiredseparation = self.separationdist        steer = Vector3(0, 0, 0)        count = 0.0        # For every boid in the system, check if it's too close        for other in boids:            d = distance3d_squared( self.location, other.location )            # If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)            if (d < desiredseparation) and (d > _epsilon):                # Calculate vector pointing away from neighbor                diff = Vector3.from_points(other.location, self.location)                diff /= d               # Scalar division to weight by distance                steer += diff                count += 1            # Keep track of how many        if (count < 0) or (not steer):            return Vector3(0, 0, 0)        # Average -- divide by how many        steer /= count        # Implement Reynolds: Steering = Desired - Velocity        steer.set_length( self.maxspeed )        steer -= self.velocity        if steer.length > self.maxforce:            steer.set_length( self.maxforce )        return steer    # Alignment    # For every nearby boid in the system, calculate the average velocity    def align( self, boids ):        neighbordist = self.alignmentdist        sum = Vector3(0, 0, 0)        count = 0.0        for other in boids:            d = distance3d( self.location, other.location )            if (d < neighbordist) and (d > _epsilon):                sum += other.velocity                count += 1        if (count < 1.0) or not sum:            return Vector3(0, 0, 0)        sum /= count        # Implement Reynolds: Steering = Desired - Velocity        sum.set_length( self.maxspeed )        steer = Vector3.from_points( self.velocity, sum )      # maybe other way around        if steer.length > self.maxforce:            steer.set_length( self.maxforce )        return steer    # Cohesion    # For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location    def cohesion( self, boids ):        neighbordist = self.cohesiondist        sum = Vector3(0, 0, 0)          # Start with empty vector to accumulate all locations        count = 0.0        for other in boids:            d = distance3d_squared( self.location, other.location )            if (d < neighbordist) and (d > _epsilon):                sum += other.location       # Add location                count += 1        if (count < 1.0) or (not sum):            return Vector3(0, 0, 0)        sum /= count        return self.seek( sum )  # Steer towards the location    # A method that calculates and applies a steering force towards a target    # STEER = DESIRED MINUS VELOCITY    def seek( self, target ):        desired = Vector3.from_points( self.location, target )  # A vector pointing from the location to the target        desired.set_length( self.maxspeed )        # Steering = Desired minus Velocity        steer = Vector3.from_points( self.velocity, desired )        if steer.length > self.maxforce:            steer.set_length( self.maxforce )      # Limit to maximum steering force        return steer    def do_actions(self, Boids):        self.acceleration.make_zero()        self.location = self.body.location        self.velocity = self.body.velocity        self.flock( Boids )        return self.acceleration.copy()    def check_exit_conditions(self):        return False    def entry_actions(self):        pass    def exit_actions(self):        passclass StateFlockExplore( StateBasic ):    pass