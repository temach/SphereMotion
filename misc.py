def box_collide(mini, maxi):    all_axis = [mini.f_unit, mini.s_unit, maxi.f_unit, maxi.s_unit]    score_to_axis = {}    for axis in all_axis:        Smin, Smax = mini.project_on(axis)        Bmin, Bmax = maxi.project_on(axis)        delta_a = Smax - Smin        delta_b = Bmax - Bmin        if Smax<Bmin or Smin>Bmax:            return "...peace..."        if Smax>Bmin:            exit_score = Smax-Bmin            score_to_axis[exit_score] = axis        elif Smin<Bmax:            exit_score = Smin-Bmax            score_to_axis[exit_score] = axis    #determine least score    least_score = abs(score_to_axis.keys()[0])    for score in score_to_axis.keys():        if abs(score)<least_score:            least_score = score    best_axis = score_to_axis[least_score].get_normalised()    mini.reset_position(best_axis, least_score)    maxi.reset_position(best_axis, least_score)    print    print    print "Along,   ", best_axis    print "How far,   ", least_score    print    return "hit and whack!"def zero_to_p(v4list, get_far):    # get_far  = bool value to indicate if the biggest or    # the smallest distance is needed    d_to_p = {}    for p in v4list:        distance = p[0]**2 + p[2]**2        d_to_p[distance] = p    list_of_d = sorted( d_to_p.keys() )    if get_far:        correct_d = list_of_d[-1] # farthest    elif not get_far:        correct_d = list_of_d[0] # closest    return d_to_p[correct_d]def cut_num(n, accuracy=6):    """Formats a number in a friendly manner    (removes trailing zeros and unneccesary point)."""    fs = "%."+str(accuracy)+"f"    str_n = fs%float(n)    if '.' in str_n:        str_n = str_n.rstrip('0').rstrip('.')    if str_n == "-0":        str_n = "0"    return str_ndef ra_collidepoint(p, r): #Rectangle of 2 vertices and area;  Rect by Area    if r[0] <= p[0] and p[0] <= r[0]+r[2]:        if r[1] <= p[2] and p[2] <= r[1]+r[3]:            return True    return Falsedef get_vec_projected(vector, planenormal):    """    'planenormal' must be a Vector3 type of unit length.    'vector' must be Vector3 type object or equivalent.    """    nx, ny, nz = planenormal    x, y, z = vector    d = nx*x + ny*y + nz*z    new_vec = vector + (planenormal * -d)    dp = new_vec.get_normalised().dot( planenormal.get_normalised() )    if dp < 0.001 and dp > -0.001:        print "good dp of %.6f   for d of %.6f" % (dp, d)    else:        print "bad dp of %.6f   for d of %.6f" % (dp, d)    return new_vec