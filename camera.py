import mathfrom OpenGL.GL import *from OpenGL.GLU import *import randomimport pygamefrom pygame.locals import *from agk.matrix44 import Matrix44from agk.vector3 import Vector3from agk.quaternion import Quaternion, nlerp, get_quat_to#m = Matrix44(1, 0, 0, 0, 0,  0.999968,  0.008037, 0, 0, -0.008037,  0.999968, 0, 0, 23, -0.000554, 1 )PI_OVER_2 = math.pi/2.0class Camera(object):    def __init__(self, RotationSpeed=math.radians(100.0), MotionSpeed=15.0, StartDirection=(0.0, 0.0, 0.0),   StartPosition=(23.0, 0.0, 0.0)):        self.matrix = Matrix44()        self.roto_dir = Vector3()        self.motion_dir = Vector3()        self.rotation_speed = RotationSpeed        self.movement_speed = MotionSpeed        self.matrix.translate = StartPosition        self.location = Vector3(StartPosition)       # an extra frequently used from the outside        rotation_matrix = Matrix44.xyz_rotation(*StartDirection)        self.matrix *= rotation_matrix        self.quat = Quaternion.from_matrix( self.matrix )        print "THIS IS THE BEGINNING"        print self.quat        self.frames = 0        self.stabilise_camera = False    def upload_matrix(self):        self.matrix.translate = self.location        glLoadMatrixd(self.matrix.get_inverse().to_opengl())    def reset_deltas(self):        """ directions given to us by the User in glory himself!"""        self.roto_dir.set(0.0, 0.0, 0.0)        self.motion_dir.set(0.0, 0.0, 0.0)    def update(self, TimeDelay):        if self.motion_dir:         # change displacement            pos = self.location            direction = Vector3(self.matrix.z_axis[:3]) * self.motion_dir.z + Vector3(self.matrix.x_axis[:3]) * self.motion_dir.x            delta_pos = direction * self.movement_speed * TimeDelay            quat_pos = Quaternion.from_two_vec3( pos, pos + delta_pos ).get_normalised()            self.location = quat_pos.rotate_vec3( pos )            self.quat = quat_pos * self.quat        # tilt the camera, to help keep it parallel to sphere's surface        if self.roto_dir:       # rotate according to user input (keyboard and/or mouse)            rotation = self.roto_dir * self.rotation_speed * TimeDelay            quat_roto = Quaternion.from_euler_angles( *rotation )            self.quat = self.quat * quat_roto        if self.stabilise_camera:       # fix the x axis to be parallel to the sphere surface            to_origin = -self.location.get_normalised()            myright = Vector3(self.matrix.x_axis[:3])            dot = myright.dot( to_origin )            if dot > 0.1:                axis = to_origin.cross( myright )            elif dot < -0.1:                axis = to_origin.cross( myright )            if abs(dot) > 0.1:                rad = PI_OVER_2 - math.acos( dot )                full_stable_quat = Quaternion.from_angle_axis( rad, axis).get_normalised()                koeff = min( TimeDelay, 0.08 ) * 10.0                stable_quat = nlerp( koeff, Quaternion(), full_stable_quat, shortest=True)                self.quat = stable_quat * self.quat        self.matrix = self.quat.normalise().to_matrix44()        self.reset_deltas()        # debug        self.frames += 1        if self.frames%10==0:            pygame.display.set_caption( "Position: {0:.3f}, {1:.3f}, {2:.3f}".format( *self.matrix.translate ) )    def detect_motion_input(self, pressed):        #look left, right        if pressed[K_q]:            self.roto_dir.y = +1.0        elif pressed[K_e]:            self.roto_dir.y = -1.0        # look up, down        if pressed[K_DOWN]:            self.roto_dir.x = -1.0        elif pressed[K_UP]:            self.roto_dir.x = +1.0        #tilt head left, right        if pressed[K_RIGHT]:            self.roto_dir.z = -1.0        elif pressed[K_LEFT]:            self.roto_dir.z = +1.0        #move forwards, backwards        if pressed[K_w]:            self.motion_dir.z = -1.0        elif pressed[K_s]:            self.motion_dir.z = +1.0        #move right, left        if pressed[K_a]:            self.motion_dir.x = -1.0        elif pressed[K_d]:            self.motion_dir.x = +1.0        if pressed[K_g]:            self.stabilise_camera = not self.stabilise_camera    def detect_rotation_input(self, mouse_rel):        threshold = 1.0                 # so we don't respond to tiny mouse motion        sensitivity = 6.0               # mouse sensitivity ( smaller == more sensitive )        max_roto = 6.0                   # max rotation speed        min_roto = 2.0                   # min rotation speed        xrel, yrel = mouse_rel              # typical values are around 0-30        xabs, yabs = abs(xrel), abs(yrel)        if xabs > 120 or yabs > 120:      # from time to time pygame throws really high mouse rels, just ignore them            return        if xabs > threshold:            roto_y = min( xabs/sensitivity + min_roto, max_roto)            self.roto_dir.y += math.copysign( roto_y, -xrel )        if yabs > threshold:            roto_x = min( yabs/sensitivity + min_roto, max_roto)            self.roto_dir.x += math.copysign( roto_x, -yrel )    def draw_rect(self, abox, colour=None):        if colour==None:            colour =(0.0,0.0,0.0)        glColor(colour)        glNormal3fv((0,1,0))        glBegin(GL_QUADS)        for v in abox.vertices:            glVertex3fv(v)        glEnd()'''if self.stabilise_camera:    to_origin = -self.location.get_normalised()    #myup = Vector3( self.matrix.y_axis[:3] )    #y_dot = myup.dot( to_origin )    # if abs(dot)>0.2 >>> player is trying to rotate on the sphere's surface    #if abs(y_dot) > 0.2:        # stabilise y-axis     #   y_quat = Quaternion.from_two_vec3( myup, to_origin, dotprod=y_dot ).get_normalised()    myright = self.quat.rotate_vec3( Vector3(1.0, 0.0, 0.0) ) #Vector3(self.matrix.x_axis[:3])   # fix the x axis to be parallel to the sphere surface    dot = myright.dot( to_origin )    print dot    if  abs(dot) > 0.1:     # stabilise x-axis        other_dot = math.copysign( 1.0 - dot, dot )             # this is a hack.        full_quat = Quaternion.from_two_vec3( to_origin, myright, dotprod=other_dot ).get_normalised()        koeff = min( TimeDelay, 0.08 ) * 5.0        quat = nlerp( koeff, Quaternion(1.0), full_quat, shortest=True)        self.quat = full_quat * self.quat        self.stabilise_camera = False'''