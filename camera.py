import mathfrom OpenGL.GL import *from OpenGL.GLU import *import randomimport pygamefrom pygame.locals import *from agk.matrix44 import Matrix44from agk.vector3 import Vector3from agk.quaternion import Quaternion, get_quat_to, nlerp#m = Matrix44(1, 0, 0, 0, 0,  0.999968,  0.008037, 0, 0, -0.008037,  0.999968, 0, 0, 23, -0.000554, 1 )class Camera(object):    def __init__(self, RotationSpeed=math.radians(100.0), MotionSpeed=15.0, StartDirection=(0.0, 0.0, 0.0),   StartPosition=(0.0, 0.0, 23.0)):        self.matrix = Matrix44()        self.roto_dir = Vector3()        self.motion_dir = Vector3()        self.rotation_speed = RotationSpeed        self.movement_speed = MotionSpeed        self.matrix.translate = StartPosition        self.location = Vector3(StartPosition)       # an extra frequently used from the outside        rotation_matrix = Matrix44.xyz_rotation(*StartDirection)        self.matrix *= rotation_matrix        self.frames = 0    def upload_matrix(self):        self.matrix.translate = self.location        glLoadMatrixd(self.matrix.get_inverse().to_opengl())    def reset_deltas(self):        """ directions given to us by the User in glory himself!"""        self.roto_dir.set(0.0, 0.0, 0.0)        self.motion_dir.set(0.0, 0.0, 0.0)    def location_update(self, TimeDelay):        direction = Vector3(self.matrix.z_axis[:3]) * self.motion_dir.z + Vector3(self.matrix.x_axis[:3]) * self.motion_dir.x        delta_pos = direction * self.movement_speed * TimeDelay        dq_pos = get_quat_to( pos, pos + delta_pos )        return dq_pos.transform_vec( pos )    def update_rotation(self, TimeDelay):        rotation = self.roto_dir * self.rotation_speed * TimeDelay        rotation_matrix = Matrix44.xyz_rotation( *rotation )        return self.matrix * rotation_matrix    def update(self, TimeDelay):        pos = self.location        if self.motion_dir:         # change displacement            direction = Vector3(self.matrix.z_axis[:3]) * self.motion_dir.z + Vector3(self.matrix.x_axis[:3]) * self.motion_dir.x            delta_pos = direction * self.movement_speed * TimeDelay            dq_pos = get_quat_to( pos, pos + delta_pos )            self.location = dq_pos.transform_vec( pos )        if self.roto_dir:       # rotate according to user input (keyboard and/or mouse)            rotation = self.roto_dir * self.rotation_speed * TimeDelay            rotation_matrix = Matrix44.xyz_rotation( *rotation )            self.matrix = self.matrix * rotation_matrix        if self.motion_dir:      # tilt the camera, to help keep it parallel to sphere's surface            koeff = min( TimeDelay, 0.08 ) * 10            roto_q = nlerp( koeff*10, Quaternion(1.0), dq_pos.get_normalised(), shortest=True)            dq_m = dq_pos.get_conjugated().get_inversed().to_matrix44()            self.matrix = dq_m * self.matrix        to_origin = -self.location.get_normalised()        myup = Vector3( self.matrix.y_axis[:3] )        # if abs(dot)>0.2 >>> player is trying to rotate on the sphere's surface        if abs(myup.dot( to_origin )) > 0.2:         # fix the x axis to be parallel to the sphere surface            myright = Vector3(self.matrix.x_axis[:3])            dot = myright.dot( to_origin )            if  abs(dot) > 0.1:                other_dot = math.copysign( 1.0 - dot, dot )             # this is a hack.                full_quat = get_quat_to( to_origin, myright, dotprod=other_dot )                koeff = min( TimeDelay, 0.08 ) * 5.0                quat = nlerp( koeff, Quaternion(1.0), full_quat, shortest=True)                self.matrix = quat.to_matrix44() * self.matrix        self.reset_deltas()        # debug        self.frames += 1        if self.frames%10==0:            pygame.display.set_caption( "Position: {0:.3f}, {1:.3f}, {2:.3f}".format( *self.matrix.translate ) )    def detect_motion_input(self, pressed):        #look left, right        if pressed[K_q]:            self.roto_dir.y = +1.0        elif pressed[K_e]:            self.roto_dir.y = -1.0        # look up, down        if pressed[K_DOWN]:            self.roto_dir.x = -1.0        elif pressed[K_UP]:            self.roto_dir.x = +1.0        #tilt head left, right        if pressed[K_RIGHT]:            self.roto_dir.z = -1.0        elif pressed[K_LEFT]:            self.roto_dir.z = +1.0        #move forwards, backwards        if pressed[K_w]:            self.motion_dir.z = -1.0        elif pressed[K_s]:            self.motion_dir.z = +1.0        #move right, left        if pressed[K_a]:            self.motion_dir.x = -1.0        elif pressed[K_d]:            self.motion_dir.x = +1.0    def detect_rotation_input(self, mouse_rel):        threshold = 1.0                 # so we don't respond to tiny mouse motion        sensitivity = 6.0               # mouse sensitivity ( smaller == more sensitive )        max_roto = 6.0                   # max rotation speed        min_roto = 2.0                   # min rotation speed        xrel, yrel = mouse_rel              # typical values are around 0-30        xabs, yabs = abs(xrel), abs(yrel)        if xabs > 120 or yabs > 120:      # from time to time pygame throws really high mouse rels, just ignore them            return        if xabs > threshold:            roto_y = min( xabs/sensitivity + min_roto, max_roto)            self.roto_dir.y += math.copysign( roto_y, -xrel )        if yabs > threshold:            roto_x = min( yabs/sensitivity + min_roto, max_roto)            self.roto_dir.x += math.copysign( roto_x, -yrel )    def draw_rect(self, abox, colour=None):        if colour==None:            colour =(0.0,0.0,0.0)        glColor(colour)        glNormal3fv((0,1,0))        glBegin(GL_QUADS)        for v in abox.vertices:            glVertex3fv(v)        glEnd()