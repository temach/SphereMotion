#!/usr/bin/env python-32import mathfrom OpenGL.GL import *from OpenGL.GLU import *import pygamefrom pygame.locals import *from agk.matrix44 import *from agk.vector3 import *#Import my stuffimport cameraimport mapdef resize(width, height):    glViewport(0, 0, width, height)    glMatrixMode(GL_PROJECTION)    glLoadIdentity()    gluPerspective(67.0, float(width)/height, .1, 1000.)    glMatrixMode(GL_MODELVIEW)    glLoadIdentity()def init():    glEnable(GL_COLOR_MATERIAL)    glEnable(GL_DEPTH_TEST)    glEnable(GL_LIGHTING)    #glEnable(GL_CULL_FACE)    glShadeModel(GL_FLAT)    glClearColor(0.5, 0.78, 1.0, 0.0)  # Nice blue colour, actually we almost never get to see it.    glLight(GL_LIGHT0, GL_AMBIENT, (0.2, 0.2, 0.2))         # where the light is dark, (the colour of the shade)    glLight(GL_LIGHT0, GL_DIFFUSE, (0.5, 0.9, 0.5))         # surrounding objects will be illuminated with this color    glLight(GL_LIGHT0, GL_SPECULAR, (1.0, 1.0, 1.0))        # shiny surfaces will reflect the light as this colour    glEnable(GL_LIGHT0)    glLight(GL_LIGHT0, GL_POSITION,  (0.0, 0.0, 1.0, 1.0))    glEnable(GL_FOG)    glFogfv(GL_FOG_COLOR, (1.0, 0.7, 0.7))    glFogi(GL_FOG_MODE, GL_EXP2)            # GL_EXP2, GL_LINEAR    glFogf(GL_FOG_START, 1.0)    glFogf(GL_FOG_END, 3.5)    glFogf(GL_FOG_DENSITY, 0.02)"""To get moving torch light effect consider:GL_POSITION, GL_SPOT_DIRECTION and GL_SPOT_CUTOFFamongst other things."""def run():    import pdb    fullscreen = (1280, 800)    window = (800, 600)    SCREEN_SIZE = window    pygame.init()    #screen = pygame.display.set_mode(SCREEN_SIZE, HWSURFACE|OPENGL|DOUBLEBUF|FULLSCREEN)    screen = pygame.display.set_mode(SCREEN_SIZE, HWSURFACE|OPENGL|DOUBLEBUF)    resize(*SCREEN_SIZE)    init()    #pygame.mouse.set_visible(False)    #pygame.event.set_grab(True)    clock = pygame.time.Clock()    Map = map.cls_Map()    Camera = camera.Camera()    # variables for debug    count = 0    trace = False    slow = False    while True:        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);        time_passed = clock.tick()        time_passed_seconds = time_passed/1000.        Camera.upload_matrix()        pressed = pygame.key.get_pressed()        mouse_rel = pygame.mouse.get_rel()        for event in pygame.event.get():            if event.type == QUIT:                return            if event.type == KEYUP and event.key == K_ESCAPE:                return            if event.type == KEYUP and event.key == K_l:                trace = not trace            if event.type == KEYUP and event.key == K_p:                slow = not slow        #if trace:            #pdb.set_trace()        if slow:            pygame.time.wait( 100 )        Camera.detect_motion_input(pressed)        Camera.detect_rotation_input( mouse_rel )        time_passed_seconds = min( time_passed_seconds, 0.03 )        Camera.update(time_passed_seconds)        Map.update_dynamic(time_passed_seconds)        Map.render()        #pos = Camera.matrix.translate[:3]        #glLight(GL_LIGHT0, GL_POSITION, pos)        pygame.display.flip()        count += 1if __name__ == "__main__":    run()