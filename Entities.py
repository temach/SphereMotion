import mathfrom OpenGL.GL import *from OpenGL.GLU import *from agk.matrix44 import *from agk.vector3 import *from agk.quaternion import *from Objects3d import MovingRigidColorMeshfrom States import StateMachine, StateExploringclass Goat( MovingRigidColorMesh ):    def __init__(self, *args):        super(Goat, self).__init__( *args[-5:] )        self.ready = True        self.travelled = 0      # number of meters covered on foot by the poor goat        self.frames = 0        self.motion_dir.z = 1.0        self.type = "robot"        self.path = []        self.destination = None        self.enemy = None        self.state = None        self.brain = StateMachine()        self.brain.add_state( StateExploring(self) )        #self.brain.add_state(StateChasingPlayer(self))        #self.brain.add_state(StateAvoidingPlayer(self))        self.brain.setup()        #self.velocity = Vector3()        #self.maxspeed = 0.09        #self.maxforce = 0.08    def update(self, TimeDelay, boids):        direction = Vector3(self.matrix.z_axis[:3])        motion_koeff = self.movement_speed * TimeDelay        self.velocity = direction * motion_koeff        acceleration = self.brain.think( boids )        if acceleration:            quat_roto = Quaternion.from_two_vec3( self.velocity, acceleration ).get_normalised()            quat_roto = nlerp( 0.005, Quaternion(1.0), quat_roto, shortest=True )            self.velocity += acceleration            self.quat = quat_roto * self.quat        quat_pos = Quaternion.from_two_vec3( self.location, self.location + self.velocity ).get_normalised()        self.location = quat_pos.rotate_vec3( self.location )        self.quat = quat_pos * self.quat        self.matrix = self.quat.normalise().to_matrix44()        self.matrix.translate = self.location"""        #delta_pos = super(Goat, self).update( TimeDelay )    def arrived_check(self):        d = distance3d(self.location, self.destination)        if d <= 0.5:            if self.path:                self.destination = self.path.pop(0)            else:                self.destination = self.location[:]        if self.travelled > 400:            print "NEW DIRECTION"            self.travelled = 0            self.motion_dir.z *= -1.0        self.frames += 1        if self.frames % 600 == 0:            self.roto_dir.y = 1.0"""